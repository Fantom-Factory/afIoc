Overview [#overview]
********************
'IoC' is an Inversion of Control (IoC) container and Dependency Injection (DI) framework inspired by the most excellent [Tapestry 5 IoC]`http://tapestry.apache.org/ioc.html`.

Like [Guice]`http://code.google.com/p/google-guice/`? Know [Spring]`http://www.springsource.org/spring-framework`? Then you'll love *IoC*!

- **Injection - any way *you* want it!**
  - field injection
  - ctor injection
  - it-block ctor injection - 'new make(|This|in) { in(this) }'

- **Distributed service configuration**
  - configure *any* service *from* any **pod** / **module**
  - configure via simple Lists and Maps

- **Override everything**
  - override services and configuration, even override your overrides!
  - replace real services with test services
  - set sensible defaults and let users override them

- **True lazy loading**
  - services can be proxied to ensure nothing is created until you actually use it
  - make circular service dependencies a thing of the past!

- **Advise services with aspects**
  - intercept method calls to your services
  - apply cross cutting concerns such as authorisation, transactions and logging

- **Extensible**
  - inject your own objects, not just services

- **Designed to help YOU the developer!**
  - simple API - 1 facet and 2 registry methods is all you need!
  - over 70 bespoke and informative Err messages!
  - Extensively tested: - 'All tests passed! [37 tests, 221 methods, 482 verifies]'

> **ALIEN-AID:** See [Fantom-Factory]`http://www.fantomfactory.org/tags/afIoc` for IoC tutorials.



Install [#Install]
******************
Install '@{project.name}' with the Fantom Repository Manager ( [fanr]`docFanr::Tool.install` ):

  C:\> fanr install -r http://repo.status302.com/fanr/ @{pod.name}

To use in a [Fantom]`http://fantom.org/` project, add a dependency to 'build.fan':

  depends = ["sys 1.0", ..., "@{pod.name} @{pod.version}+"]



Documentation [#documentation]
******************************
Full API & fandocs are available on the [Status302 repository]`http://repo.status302.com/doc/@{pod.name}/`.



Quick Start [#quickStart]
*************************
1). Create a text file called 'Example.fan'
pre>
using afIoc

// ---- Services are plain Fantom classes -------------------------------------

class MyService1 {
    ** Inject services into services!
    @Inject MyService2? service2
}

class MyService2 {
    Void poke() { echo("Poking ${this.toStr}") }
}



// ---- Modules are where services are defined and configured -----------------

** Every application needs a module class
class MyModule {
    static Void defineServices(ServiceDefinitions defs) {
        defs.add(MyService1#)
        defs.add(MyService2#)
    }
}



// ---- Build and start the IoC Registry --------------------------------------

class Main {
    Void main() {
        registry := RegistryBuilder().addModule(MyModule#).build().startup()

        test1 := (MyService1) registry.serviceById("myservice1")       // returns a singleton
        test2 := (MyService1) registry.dependencyByType(MyService1#)   // returns the same singleton
        test3 := (MyService1) registry.autobuild(MyService1#)          // build a new instance
        test4 := (MyService1) registry.injectIntoFields(MyService1())  // inject into existing Objs

        // all test classes poke the same instantce of Service2
        test1.service2.poke
        test2.service2.poke
        test3.service2.poke
        test4.service2.poke

        registry.shutdown()
    }
}
<pre

2). Run 'Example.fan' as a Fantom script from the command line:

pre>
C:\> fan Example.fan

[info] [afIoc] Adding module definition for Example_0::MyModule
[info] [afIoc] Starting IoC...

12 Services:

     Example_0::MyService1: Defined
     Example_0::MyService2: Defined
         afIoc::ActorPools: Builtin
afIoc::DependencyProviders: Builtin
        afIoc::LogProvider: Builtin
           afIoc::Registry: Builtin
       afIoc::RegistryMeta: Builtin
   afIoc::RegistryShutdown: Builtin
    afIoc::RegistryStartup: Builtin
afIoc::ServiceProxyBuilder: Builtin
 afIoc::ThreadLocalManager: Builtin
afPlastic::PlasticCompiler: Builtin

16.67% of services are unrealised (2/12)

   ___    __                 _____        _
  / _ |  / /_____  _____    / ___/__  ___/ /_________  __ __
 / _  | / // / -_|/ _  /===/ __// _ \/ _/ __/ _  / __|/ // /
/_/ |_|/_//_/\__|/_//_/   /_/   \_,_/__/\__/____/_/   \_, /
                            Alien-Factory IoC v2.0.4 /___/

IoC Registry built in 205ms and started up in 11ms

[warn] [afIoc] Autobuilding type 'Example_0::MyService1' which is *also* defined as service 'Example_0::MyService1 - unusual!

Poking fan.Example_0.MyService2@680e2291
Poking fan.Example_0.MyService2@680e2291
Poking fan.Example_0.MyService2@680e2291
Poking fan.Example_0.MyService2@680e2291

[info] [afIoc] Stopping IoC...
[info] [afIoc] IoC shutdown in 19ms
[info] [afIoc] "Goodbye!" from afIoc!
<pre



Terminology [#terminology]
**************************
A **service** is a Fantom class whose instances are created and managed by IoC. It ensures only a single instance is created for the whole application or thread. Services are identified by a unique ID (usually the qualified class name). Services must be defined in a **module**. Services may solicit, and be instantiated with, configuration data defined in multiple modules.

A **dependency** is any class instance or object that a service depends on. A dependency may or may not be a service. Non service dependencies are managed by user defined [dependency providers]`DependencyProvider`.

A **module** is a class whose static methods define and configure services.

The **registry** is the key class in an IoC application. It creates, holds and manages the service instances.



The IoC Registry [#theIocRegistry]
**********************************
Frameworks such as [BedSheet]`pod:afBedSheet` and [Reflux]`pod:afReflux` are IoC containers. That is, they create and look after a 'Registry' instance, using it to create classes and provide access to services.

Sometimes you don't have access to an IoC container and have to create the 'Registry' instance yourself. (Running unit tests is a good example.) In these cases you will need to use the `RegistryBuilder`, passing in the module that defines your services:

  registry := RegistryBuilder().addModule(AppModule#).build().startup()
  ...
  service  := registry.serviceById("serviceId")
  ...
  registry.shutdown

If your code uses other IoC libraries, make sure modules from these pods are added too. Example, if using the [IocEnv library]`pod:afIocEnv` then add a dependency on the 'afIocEnv' pod:

  registry := RegistryBuilder()
      .addModule(MyModule#)
      .addModulesFromPod("afIocEnv")
      .build().startup()



Fantom Services [#fantomServices]
=================================
The Fantom language has the notion of application wide [services]`sys::Service`. Should your application make use of this mechanism, IoC provides the `IocService` wrapper class that holds a 'Registry' instance and extends Fantom's [Service]`sys::Service`. It also contains convenience methods for creating and accessing the registry.

For example, to create and start a Fantom IoC Service:

  IocService([ MyModule# ]).start()

Then, from anywhere in your code, use the standard Fantom service methods to locate the 'IocService' instance and query the registry:

  iocService := (IocService) Service.find(IocService#)
  ...
  myService  := iocService.dependencyByType(MyService#)

Uninstall 'IocService' like any other:

  Service.find(IocService#).uninstall()



Modules [#modules]
******************
Every IoC application / library will have a module class. Module classes are where services are defined and configured. Module classes declare static methods with special facets that tell IoC what they do.

By convention an application will call its module 'AppModule' and libraries will name modules after themselves, but with a 'Module' suffix. Example, BedSheet has a module named 'BedSheetModule'.



Pod Meta-data [#metaData]
=========================
It is good practice, when writing an IoC application or library, to always include the following meta in the 'build.fan'

  meta = [ "afIoc.module" : "<module-qname>" ]

Where '<module-qname>' is the qualified type name of the pod's main module class.

This is how IoC knows what modules each pod has. It is how the 'addModulesFromPod("afIocEnv")' line works; IoC inspects the meta-data in the 'afIocEnv' pod and looks up the 'afIoc.module' key. It then loads the modules listed.

The 'afIoc.module' meta may also be a Comma Separated List (CSV) of module names; handy if the pod has many modules. Though it is generally better (more explicit / less prone to error) to use the [@SubModule]`SubModule` facet on a main 'AppModule' class.



Services [#services]
********************
A service can be any old Fantom class. What differentiates a *service* from any other class is that you typically want to reuse a service in multiple places. An IoC Service is a class that is created and held by the IoC Registry. IoC may then inject that service into other classes, which may themselves be services.

For IoC to instantiate and manage a service it needs to know:

 - How to build the service
 - What unique ID to store it under
 - What scope it has (application or threaded)
 - What its proxy strategy is.

(Scopes and proxy strategies are covered later, as they're kinda advanced topics.)

All these details are defined in the application's module.

Note that IoC does not want an instance of your service. Instead it wants to know how to make it. That is because IoC will defer creating your service for as long as possible (lazy loading).

If nobody ever asks for your service, it is never created. When the service is explicitly asked for, either by you or by anther service, only then is it created.



Build Your Own [#buildYourOwn]
==============================
If we have a class 'MyService' that we wish to use as a service, then we need to tell IoC how to build it. The simplest way is to declare a static *build* method in the module that creates the instance for us:

pre>
using afIoc

// example 1
class AppModule {

    @Build
    static MyService buildMyService() {
        return MyService()
    }
}
<pre

The method may be called anything you like and be of any scope (internal or even private), but it needs to be 'static' and it needs the '@Build' facet.

Because of the '@Build' facet, IoC inspects the method and infers the following:

 - Calling the method creates a service instance - *inferred from '@Build'*
 - The service is of type 'MyService' - *inferred from the return type*
 - The unique ID is 'myPod::MyService' - *inferred from the return type's qualified name*

We could now retrieve an instance of 'MyService' with the following:

  myService := (MyService) registry.serviceById(MyService#.qname)

  myService := (MyService) registry.dependencyByType(MyService#)

What if 'MyService' created penguins? Well, it'd be useful to have a 'Penguins' class / service to hold them in. We'll pass that into 'MyService'. We'll also tell 'MyService' how many penguins it should make:

  class MyService {
      new make(Int noOfPenguins, Penguins penguins) { ... }
  }

The 'AppModule' now needs updating with a builder method for the 'Penguins' service, and the 'MyService' builder method needs updating also:

pre>
using afIoc

// example 2
class AppModule {

    @Build
    static Penguins buildPenguins() {
       return Penguins()
    }

    @Build
    static MyService buildMyService(Penguins penguins) {
        return MyService(3, penguins)
    }
}
<pre

Before IoC calls 'buildMyService()' it looks at the method signature and assumes any parameters are dependant services. In this case, 'Penguins'. It then looks up, and creates if it doesn't already exist, the 'Penguins' service and passes it to 'buildMyService()'. This is an example of *method injection*. All this is automatic, and all builder methods may declare any number of services as a method parameters.

Note that the '@Build' facet has other attributes that give you control over the service's unique ID, scope and proxy strategy.

Service builder methods are a very powerful pattern as they give you complete control over how the service is created. But they are also very verbose and require a lot of code. So lets look at an easier way; the 'defineServices()' method...



Defining Services [#definingServices]
=====================================
Modules may declare a 'defineServices()' static method. It may be of any visibility but must be called 'defineServices' and it must define a single parameter of 'ServiceDefinitions'. The method lets you create and add service definitions in place of writing builder methods.

We could replace the previous 'example 1' with the following:

pre>
using afIoc

class AppModule {
    static Void defineServices(ServiceDefinitions defs) {
        defs.add(MyService#)
    }
}
<pre

It may look simple, but several things are inferred from the above code:

 - The service is of type 'MyService' - *inferred from the service type*
 - The unique ID is 'myPod::MyService' - *inferred from the service type's qualified name*
 - 'MyService' may be instantiated by IoC.

Now lets replace 'example 2':

pre>
using afIoc

class AppModule {
    static Void defineServices(ServiceDefinitions defs) {
        defs.add(MyService#).withCtorArgs([ 3 ])
        defs.add(Penguins#)
    }
}
<pre

That's a lot more succinct! But wait! We gave 'MyService' a ctor arg of '3', but what about 'Penguins'? All supplied ctor arguments must come first in the parameter list, because all non-supplied ctor args are taken to be services. These services, same as in method injection, are resolved, built if needed, and handed to the ctor. This is an example of *ctor injection*.



Dependency Injection [#dependencyInjection]
*******************************************
IoC performs both ctor and field injection, for normal and const fields.

Note that under the covers, all services are resolved via their unique service ids, injection by type is merely a layer on top, added for convenience.

When IoC autobuilds a service it locates a suitable ctor. This is either the one donned with the '@Inject' facet or the one with the most parameters. Ctor parameters are taken to be dependencies and are resolved appropriately.

Field injection happens *after* the object has been created and so fields must be declared as nullable:

pre>
class MyService {
  @Inject
  MyService? myService
}
<pre

The exception is if you declare an it-block ctor:

pre>
const class MyService {
  @Inject
  const MyService myService

  new make(|This|? f := null) { f?.call(this) }
}
<pre

On calling 'f' all injectable fields are set, even fields marked as 'const'. The it-block ctor may be abbreviated to:

  new make(|This| f) { f(this) }

After object construction and field injection, any extra setup may be performed via methods annotated with '@PostInjection'. These methods may be of any visibility and all parameters are resolved as dependencies.



Service Scope [#serviceScope]
*****************************
Services are either created once [perApplication]`ServiceScope#perApplication` (singletons) or once [perThread]`ServiceScope#perThread`. Application scoped services *must* be defined as 'const'.

(Using proxies) you can even inject a 'perThread' scoped service into a 'perApplication' scoped service! Think about it... you can inject your [http request]`web::WebReq` into any static service you desire!



Service Configuration [#serviceConfiguration]
*********************************************
Services can solicit configuration from modules simply by declaring a list or a map in their ctor or builder method.

pre>
  class Example {

    new make(Str[] mimeTypes) { ... }
    ...
  }
<pre

Modules may then contribute to the 'Example' service:

pre>
class AppModule {

  @Contribute { serviceType=Example# }
  static Void contributeExample(Configuration conf) {
    conf.add("text/plain")
  }
}
<pre

The list and map types are inferred from the ctor definition and all contribution types must fit.

Think of 'Configuration' as an ordered Map that collects data from *all* the IoC modules.
The collected data / Map is then passed to the ctor of the service.
If the service ctor takes a List then just the Map values are passed.



Lazy Loading [#lazyLoading]
***************************
Define your service with a mixin and take advantage of true lazy loading!

By fronting your service with a mixin, IoC can generate and compile a service proxy on the fly.
The *real* service is only instantiated when you call a method on the proxy.

This means circular service dependencies are virtually eliminated!

It also allows you to inject 'perThread' scoped services into 'perApplication' scoped services.



Advise Your Services [#adviseYourServices]
******************************************
Intercept all method calls to proxied services and wrap them in your own code!

See [@Advise]`Advise` for details



Tips [#tips]
************
Strive to keep your services 'const', declare a serialisation ctor to keep '@Inject'ed fields non-nullable:

  new make(|This| injectInto) { injectInto(this) }

Define one main module and declare it in both the pod meta and the pod index props. Use '@SubModule' to reference additional dependant modules in the same pod.

If you have no say in how your classes are created (say, when you're using flux) then use the following line to inject dependencies when needed:

  ((IocService) Service.find(IocService#)).injectIntoFields(this)

When creating GUIs (say, with fwt) then use [Registry.autobuild()]`Registry#autobuild` to create your panels, commands and other objects. These aren't services and should not be declared as such, but they do often make use of services.

IoC gives detailed error reporting should something go wrong, nevertheless try turning debug logging on to make IoC give trace level contextual information.

Don't be scared of creating 'const' services! Use the [Concurrent]`pod:afConcurrent` library to safely store and access mutable state across thread boundaries.



Release Notes [#releaseNotes]
*****************************
v2.0.4 [#2.0.4]
===============
 - Bug: '@Autobuild' fields could be created twice if an it-block ctor was used.

v2.0.2 [#2.0.2]
===============
 - Chg: 'perApplication' scoped services can only be created once, even during threaded race conditions.
 - Chg: Added 'withCtorArgs()' and 'withFieldVals()' to 'ServiceDefinitions'; building custom services is now even easier!
 - Chg: 'LocalProvider' takes into account '@Inject.type' when injecting 'LocalLists' and 'LocalMaps'. See `ThreadLocalManager`.
 - Chg: 'RegistryBuilder.addModulesFromPod()' now takes a Str (pod name), not a pod instance.
 - Chg: 'DependencyProviders' is more accessible for efanXtra.
 - Bug: 'ServiceDefinitions.withImplId()' should not have taken an Id parameter.

v2.0.0 [#2.0.0]
===============
 - New: All attributes of a service (scope, proxy, etc...) may be overridden.
 - New: '@Override' facet for defining service override methods in 'AppModule'.
 - New: '@Autobuild' facet for injecting non-service instances.
 - New: 'ServiceDefinitions', 'ServiceDefinitionOptions' and 'ServiceOverrideOptions' replaces 'ServiceBinder' et al.
 - New: Added 'RegistryBuilder.removeModule()'.
 - Chg: Optomised and reduced internal code - **now 20% faster!**
 - Chg: Services are not proxied unless they need to be; e.g. it has method advice, or is thread scope being injected into an app scoped service. (Potential breaking change.)
 - Chg: 'DependencyProviders' are applied to *all* fields, '@Inject' facet is no longer required.
 - Chg: Deleted 'autobuild' from '@Inject' facet in favour of a new-ish '@Autobuild' facet. (Breaking change.)
 - Chg: Default serviceId for '@Build' methods is now the qualified name of the return Type. (Potential breaking change.)
 - Chg: Deleted 'ServiceOverrides' service in favour of service '@Override' methods. (Breaking change.)
 - Chg: Deleted 'ServiceStats' service in favour of method 'Registry.serviceDefinitions()'. (Breaking change.)
 - Chg: Deleted all existing @Deprecated classes. (Breaking change.)
 - Chg: 'LogProvider' service may be overridden to ensure it provides *all* injected 'Log' instances. (Breaking change.)
 - Chg: Renamed 'ServiceStat' -> 'ServiceDefinition'. (Breaking change.)
 - Chg: Lower cased the names of the 'ServiceLifecycle' enum. (Breaking change.)
 - Chg: Merged 'LocalRefProvider', 'LocalListProvider' and 'LocalMapProvider' into the one 'LocalProvider'.
 - Bug: 'IocService' methods now more closely follow those of 'Registry'.

v1.7.6 [#1.7.6]
===============
 - New: Added a dedicated 'IocShutdownErr' throw when registry methods are invoked after it has been shutdown.
 - Chg: Added 'checked' parameter to 'Registry.serviceById()'.
 - Chg: Removed the little used 'Unwrappable' Err mixin.
 - Bug: 'RegistryBuilder' could potentially throw an Err when adding both modules and pods.

v1.7.4 [#1.7.4]
===============
 - Bug: Configuration contributions added via 'set()' did not have any implied ordering constraints.

v1.7.2 [#1.7.2]
===============
 - Chg: Configuration ordering constraints are no longer specified with strings. Use the new 'Constraints' class to pass your Obj keys in.
   This avoids problems with 'toStr()' and string keys with commas.

v1.7.0 [#1.7.0]
===============
 - New: All service configuration is done through the *uber* 'Configuration' object.
 - New: Configuration IDs can now be injected by specifying a Map rather than a List.
 - New: Added '@Advise.serviceType' for advising a single service.
 - Chg: Deprecated 'OrderedConfig' and 'MappedConfig' in favour of 'Configuration'.
 - Chg: Aspect invoker references 'null' instead of an empty list when holding method advice.
 - Chg: 'LocalRefProvider', 'LocalListProvider' and 'LocalMapProvider' now use the Type's qualified name as the key
 - Chg: Deleted all existing @Deprecated classes.
 - Bug: Could not always contribute empty maps and lists created with shorthand notation, e.g. '[,]'.

v1.6.4 [#1.6.4]
===============
 - New: Methods on proxied services may now have *plain* default values - 'Plastic' will attempt to *guess* what they are!
 - Chg: Removed deprecated classes 'TypeCoercer, StrategyRegistry' and 'NotFoundErr'.
 - Chg: Changed the default values for some 'Registry' methods to 'null' (from 'Obj#.emptyList').
 - Chg: Moved the startup logging to 'RegistryStartup' contributions so they could easily be removed / overridden.
 - Chg: Removed the 'RegistryBuilder' options 'logServiceCreation, disableProxies, suppressStartupBanner' and 'suppressStartupServiceList'.
 - Chg: Gave the IoC 'ActorPool' a name.
 - Bug: Could not autobuild nullable types.

v1.6.2 [#1.6.2]
===============
 - New: Threaded services can be overriden.
 - New: Using [Bean Utils 0.0.2]`pod:afBeanUtils`
 - Chg: Deleted all previous '@Deprecated' classes and methods.
 - Chg: Deprecated 'TypeCoercer, StrategyRegistry' and 'NotFoundErr' in favour of new [Bean Utils]`pod:afBeanUtils` library.
 - Chg: Type checks involving Lists and Maps when calling methods and ctors are more lenient.
 - Chg: Renamed 'RegistryShutdownHub' -> 'RegistryShutdown'. Shutdown listeners are deprecated, use standard AppModule contributions instead.
 - Chg: Renamed 'DependencyProviderSource' -> 'DependencyProviders'.
 - Chg: Renamed 'ServiceOverride' -> 'ServiceOverrides'.
 - Chg: Renamed 'InjectionType' -> 'InjectionKind'.
 - Chg: Discovered 'List.eachRange()'!
 - Chg: IoC system ActorPool is stopped on shutdown.
 - Bug: Trying to proxy a mixin with a static field gave an Err.

v1.6.0 [#1.6.0]
===============
 - New: 'Registry.dependencyByType()' now returns services via a type inheritance search.
 - New: 'LocalRefs, LocalMaps, LocalLists' instances may now be '@Inject'ed thanks to new 'DependencyProviders'
 - New: Added 'fieldVals' parameter to 'Regsitry.autobuild(...)' and 'Regsitry.createProxy(...)' so non-DI fields may also be set by an it-block.
 - New: Added 'ActorPools' class to keep tabs on ActorPools.
 - New: Added 'moduleTypes()' and 'modulePods()' to 'RegistryMeta'.
 - New: Added 'createProxy()' to 'OrderedConfig' and 'MappedConfig'.
 - Chg: Optomised internal concurrent processes - **now 20% faster!**
 - Chg: [Concurrent]`pod:afConcurrent` has been broken out into an external dependency.
 - Chg: Deprecated 'ConcurrentState, ConcurrentCache, ThreadStash' in favour of [Concurrent]`pod:afConcurrent` classes.
 - Chg: Attempting to '@Inject' into a static field will now throw an Err.
 - Chg: Renamed 'ThreadStashManager' -> 'ThreadLocalManager'
 - Chg: Renamed 'RegistryOptions' -> 'RegistryMeta'
 - Chg: Re-jigged 'RegistryBuilder' logic and API.
 - Chg: Re-jigged 'StrategyRegistry' to add 'findAllChildren()'.
 - Chg: 'TypeCoercer' is now 'const'.

v1.5.4 [#1.5.4]
===============
 - Chg: Available values in 'NotFoundErr' are now sorted alphabetically.
 - Bug: Attempting to inject or autobuild a threaded service in an app-scoped (const) service gave an error.

v1.5.2 [#1.5.2]
===============
 - New: 'TypeCoercer' converts Lists from one parameterised type to another.
 - New: 'ConcurrentCache' gets new methods: 'clear(), isEmpty(), remove(), replace(), size()'.
 - New: Added 'clearCache()' to 'TypeCoercer'.
 - New: Added 'clearCache()' to 'StrategyRegistry'.
 - Chg: Added a 'checked' parameter to 'Registry.dependencyByType()'
 - Chg: Deprecated 'ServiceBinder.bindImpl()' in favour of a nullable parameter in 'ServiceBinder.bind()'
 - Chg: Errs thrown in 'Registry.callMethod()' are no longed wrapped in an 'IocErr'.
 - Chg: Renamed '@ServiceId.serviceId' -> '@ServiceId.id'
 - Bug: 'Registry.callMethod()' could not handle methods with default arguments.
 - Bug: 'Log' could not be injected via ctor.

v1.5.0 [#1.5.0]
===============
 - New: 'Registry.createProxy()' lets you create a lazy proxy from an arbituary mixin / impl pair.
 - New: 'Registry.callMethod()' lets you invoke methods with dependencies injected into the parameters.
 - New: 'LogProvider' lets you inject 'Log' instances.
 - New: 'InjectionCtx' contains details as to what type of injection is taking place. (Renamed from 'ProviderCtx')
 - New: Service overrides can use Types as the config key.
 - Chg: When a service type is defined multiple times, a default one is returned by 'dependencyByType'.
 - Chg: Default ServiceIds are now the **fully qualified** names of the service (mixin) type. (Breaking change.)
 - Chg: Removed dependency type from 'DependencyProvider' method signatures. It moved to 'InjectionCtx'. (Breaking change.)
 - Chg: Liberated the 'PipelineBuilder' util service. It moved to BedSheet. (Breaking change.)
 - Chg: Overhauled 'InjectionCtx' to make use of ThreadStacks so it doesn't need to be passed around.

v1.4.10 [#1.4.10]
=================
 - Chg: InjectionCtx is now threaded and used in Lazy Service creation. (Um, that means more complete Operation Stacks in IocErrs!)
 - Bug: Once a proxied service, always a proxied service! In some cases the *real* service could have been returned.

v1.4.8 [#1.4.8]
===============
 - New: RegistryBuilder options are now available via `RegistryOptions`.
 - Chg: Injectable services are now documented with '(Service)'.
 - Chg: Enabled multi-line banner text.

v1.4.6 [#1.4.6]
===============
 - New: Added 'makeWithMap()' ctor and 'getOrAdd()' to 'ConcurrentCache'.
 - New: `NotFoundErr` now pretty prints available values.
 - Chg: [Plastic]`pod:afPlastic` has been broken out into an external dependency.
 - Chg: Rejigged the stack trace filter not to throw internal 'IocErrs' as the cause.
 - Bug: `DependencyProvider`s could Err when they depended on lazy services (recursion error).
 - Bug: 'ThreadStash' name prefix tidy.

v1.4.4 [#1.4.4]
===============
 - New: 'PlasticCompilationErr' gives detailed info and code snippets.
 - Chg: Made the useful 'OperationTrace' a field of `IocErr`.
 - Chg: afPlastic now generates 'using' statements.
 - Chg: Toned down `RegistryBuilder` logging.
 - Bug: 'Before' and 'After' ordering constraint prefixes were not case insensitive.

v1.4.2 [#1.4.2]
===============
 - New: Added 'ConcurrentCache' class, an application of 'ConcurrentState' designed for fast reads.
 - New: Added 'PlasticClassModel.extendClass()' for the model may now extend multiple Mixins.
 - New: Added 'PlasticClassModel.addMethod()' for adding new methods.
 - Chg: 'ConcurrentState' state may now be 'null' (and added an instance count).

v1.4.0 [#1.4.0]
===============
 - New: Added 'OrderedConfig.remove()' and 'MappedConfig.remove()'.
 - New: Added `RegistryBuilder#moduleTypes` to return a list of modules types held by the builder.
 - New: Added 'suppressStartupMsg' build option.
 - Chg: Rejigged the config override argument order. (Breaking Change.)
 - Chg: Deleted '@Deprecated' config methods.
 - Chg: Transferred VCS ownership to [AlienFactory]`https://bitbucket.org/AlienFactory`
 - Chg: Test code is no longer distributed with the afIoc.pod - pod size was nearing 500 Kb!
 - Chg: ThreadStashs have less verbose names.
 - Bug: Could not override ordered config if it was referenced by constraints.

v1.3.10 [#1.3.10]
=================
 - New: Added 'PipelineBuilder' util service.
 - Chg: [Registry.autobuild()]`Registry#autobuild` now looks for a default implementation if passed a mixin.
 - Chg: Made it clear when service creation fails due to Registry Shutdown.
 - Bug: Proxy Types for lazy services are now cached. Would have caused a memory leak when using creating lots of threaded const services.
 - Bug: Ordered contributions with multiple 'before:' constraints could be added to the config list multiple times.
 - Bug: afPlastic would only allow methods to be overridden if they were defined in the immediate parent type.
 - Bug: Stack frames were lost from Errs originating from module builder methods.

v1.3.8 [#v1.3.8]
================
 - New: Added `TypeCoercer` util class that converts an Obj to a given type using 'toXXX()' and 'fromXXX()' methods.
 - Chg: `OrderedConfig` contributions are coerced to the contrib type.
 - Chg: `MappedConfig` key and value contributions are coerced to their required types.
 - Chg: Added shortcut '@Operator This add(obj)' to `OrderedConfig` and '@Deprecated Void addUnordered(obj)'.
 - Chg: Added shortcut '@Operator This set(key, val)' to `MappedConfig` and '@Deprecated Void addMapped(key, val)'.
 - Chg: Public method on 'OrderedConfig' and 'MappedConfig' now return 'this' and other tweaks.
 - Chg: Exposed '@NoDoc PlasticPodCompiler' so it may be used outside of afIoc.

v1.3.6 [#v1.3.6]
================
 - Bug: Real impls of proxied const services were not being cached.
 - Bug: The implied order of unordered config in 'OrderedConfig' was not assured.
 - Bug: Could not inject null into const fields via a custom 'DependencyProvider'.

v1.3.4 [#v1.3.4]
================
 - Chg: `DependencyProvider`s may now provide 'null' values.
 - Chg: `OrderedConfig` values may be 'null'.
 - Chg: `MappedConfig` values may be 'null'.
 - Chg: Tweaked `OrderedConfig` placeholder default ordering logic.
 - Bug: Placeholders in 'OrderedConfig' Err'ed when config was not a Str.

v1.3.2 [#v1.3.2]
================
 - New: IocErr is thrown on startup if module advisor methods don't match any proxyable serivces.
 - New: Module advisor methods may be marked as optional.
 - New: Add thread clean up handlers to 'ThreadStashManager'.
 - New: Added 'ThreadStash#contains'
 - Chg: Operations Err trace is now part of the Err msg (and no longer logged to 'sys.err')
 - Chg: 'ConcurrentState.withState()' now returns a 'Future'.
 - Bug: Lifecyle data for threaded Services was not threaded. (Caused problems for threaded proxy services.)

v1.3.0 [#v1.3.0]
================
 - New: Simple Aspect API for advising proxied servies.
 - New: Service proxies for mixins are generated and compiled on the fly to give true lazy loading.
 - New: 'ThreadStashManager' now keeps tabs on your 'ThreadStashes' so they may be cleanup at the end of, um... say a web request!
 - Chg: Revamped 'LocalStash' into 'ThreadStash'
 - Chg: Mapped override keys can always be a Str
 - Chg: Removed Ioc frames from stack traces (no more 150+ line stacktraces!)
 - Chg: Reducded INFO logging.
 - Bug: '@Build.serivceId' was not overriding the build method name.
 - Bug: Distributed mapped overide could throw an invalid override not found err.
 - Bug: Autobuild now checks if the type is instantiable.

v1.2.2 [#v1.2.2]
================
 - Chg: `Registry#autobuild` now accepts optional parameters to pass / mix into the ctor.
 - Chg: 'ConcurrentState' now accepts a factory method for creating / initialising state.

v1.2.0 [#v1.2.0]
================
 - New: Browse defined services via `ServiceStats`
 - New: Override defined services with your own implementations via the new powerful 'ServiceOverrides' feature.
 - New: Override any existing 'OrderedConfig' contribution with you own, via 'OrderedConfig.addOverride'.
 - New: Override any existing 'MappedConfig' contribution with you own, via 'MappedConfig.addOverride'.
 - New: Ordered configurations may define 'Placeholders'.
 - Chg: [Registry shutdown listeners]`RegistryShutdownHub` may now be ordered.
 - Chg: Improved Registry startup times by only inspecting Pods (for modules) the once.
 - Chg: 'IocService' rethrows any startup Errs when getting the registry. See [Errs on Service.start()]`http://fantom.org/sidewalk/topic/2133`.

v1.1.0 [#v1.1.0]
================
 - New: Extend IoC by defining your own `DependencyProvider`s.
 - New: [@ServiceId]`ServiceId` lets you disambiguate between different implmentations of the same service mixin.
 - New: [@Autobuild]`Autobuild` injects a fresh service on every injection.
 - New: [Ordered configuration]`OrderedConfig#addOrdered` contributions are ordered across modules.
 - Bug: Services can be created even if they don't define any ctors.

v1.0.0 [#v1.0.0]
================
 - New: Added 'addUnorderedAll' and 'addMappedAll' to `OrderedConfig` and `MappedConfig`.
 - Chg: Multiple instances of 'ConcurrentState' can be created with the same state class.
 - Bug: Made public the 'withState()' and 'getState()' methods on 'ConcurrentState'.
 - Bug: NPE could be thrown if ctor depdendency not found.

v0.0.2 [#v0.0.2]
================
 - New: A fully loaded preview release.

