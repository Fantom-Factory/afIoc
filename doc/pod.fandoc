Overview [#overview]
********************
IoC is an Inversion of Control (IoC) container, or Dependency Injection (DI) framework, based on the most excellent [Tapestry 5 IoC]`http://tapestry.apache.org/ioc.html` for Java. Above and beyond other IoC containers, this IoC offers:
 - distributed service configuration between pods and modules
 - extensive error reporting
 - lazy(ish) service loading
 - case insensitivity

Quick Start [#quickStart]
*************************

pre>
class Main {
  static Void main(Str[] args) {
    registry := IocService([MyModule#]).start.registry

    MyService1 test1 := registry.serviceById("myservice1")

    MyService1 test2 := registry.dependencyByType(MyService1#)

    MyService1 test3 := registry.autobuild(MyService1#)

    MyService1 test4 := registry.injectIntoFields(MyService1())

    Service.find(IocService#).uninstall
  }
}

class MyService1 {
  @Inject
  MyService2? service2
}

class MyService2 {
  Str kick := "Ass!"
}

class MyModule {
  static Void bind(ServiceBinder binder) {
    binder.bindImpl(MyService1#)
    binder.bindImpl(MyService2#)
  }
}
<pre


Terminology [#terminology]
**************************
IoC distinguishes between **Services** and **Dependencies**.

A **service** is a singleton class of which there is only one instance (or one per thread). Each service is identified by a unique ID (usually the unqualified class name) and may, or may not, be represented by a Mixin. Services are managed by IoC and may gather configuration contributed from other modules.

A **dependency** is any class or object that another class depends on. A dependency may or may not be a service.  For example, a class may depend on having a field 'Int maxNoOfThreads' but that 'Int' isn't a service. Non service dependencies may be managed by (future) user defined dependency providers.

A **contribution** is a means to configure a service.

A **module** is a class where services and contributions are defined.


Loading Modules [#loadingModules]
*********************************
When [building a registry]`RegistryBuilder`, you declare which modules are to loaded. You may also load modules in dependant pods, in which case, each pod should have declared the following meta:

'"afIoc.module" : "{qname}"'

Where '{qname}' is a qualified type name of a module. Additional modules can be declared by the [@SubModule]`SubModule` facet.

Modules can also be loaded from index properties in a similar manner.


Defining Services [#definingServices]
*************************************
Services are defined in Module classes, where each meaningful method is static and annotated with a facet. 

The exception is 'bind()' which does not have a facet but is declared with a standard signature. The bind method is the common means to define serices, examples below:

  static Void bind(ServiceBinder binder) {

    // has service ID of 'MyService'
    binder.bind(MyService#, MyServiceImpl#)

    // has service ID of 'myServiceImpl'
    binder.bindImpl(MyServiceImpl#)
    
    // has service ID of 'elephant'
    binder.bindImpl(MyServiceImpl#).withId("elephant")    
  }

Modules may can also define *builder* methods. These are static methods annotated with the '@Build' facet.

whose name start with the prefix 'build', the rest of the method name is taken to be the service ID. To manually build a service with the Id 'penguin':

  static EmailService buildPenquin(EmailConfig config) {
    EmailServiceImpl(config)
  }

Builder methods may take dependencies as parameters. These dependencies are realised and passed in when the service is built.


Dependency Injection [#dependencyInjection]
*******************************************
IoC performs both ctor and field injection.

Note that under the covers, all services are resolved via their unique service ids, injection by type is merely a layer on top, added for convenience.

When IoC builds a service it locates a suitable ctor. This is either the one donned with the '@Inject' facet or the one with the most parameters. Ctor parameters are taken to be dependencies and are resolved appropriately.

Field injection happens *after* the object has been created and so must be declared as nullable:

  @Inject
  MyService? myService

The exception to the rule is if you declare a serialisation ctor:

pre>
class MyService1 {
  @Inject
  MyService2 service2

  new make(|This| injectInto) {
    injectInto(this)
  }
}
<pre

Note that due to [this topic]`http://www.fantom.org/sidewalk/topic/2119` 'const' fields can not be injected.

After object construction and field injection you may perform extra setup via methods annotated with the '@PostInjection' facet. These may be of any visibility and all parameters are resolved as dependencies.


Service Scope [#serviceScope]
*****************************
Services are either created once [perApplication]`ServiceScope.perApplication` (singletons) or once [perThread]`ServiceScope.perThread`. Application scoped services must be defined as 'const'. If you need mutable state in your const service, try using the `ConcurrentState` class.

It is illegal to attempt to inject a 'perThread' scoped service into a 'perApplication' scoped service.


Service Configuration [#serviceConfiguration]
*********************************************


Tips & Good Practices [#tips]
*****************************

Define both pod meta and index props. Only define one module per pod, use @SubModule for dependant modules (or defining more than one)

use 'injectInto fields of ' Flux objs (as you have no say in how they're created
use 'autobuikd' for other gui objss

most useful when building guis - a panel or content pane isn't a service, but needs access to serives. commands can be auto build on the fly to invoke serive actions

Based on T5-IoC but perhaps tries to take out some of the *magic* commonlly associated with it.